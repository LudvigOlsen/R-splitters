---
title: "Using splitters"
author: 
 - "Ludvig Renbo Olsen"
 - "Cognitive Science, Aarhus University"
 - "mail@ludvigolsen.dk | http://ludvigolsen.dk"
date: "10/29/2016"
output:
  pdf_document:
    highlight: tango
    number_sections: yes
    toc: yes
    toc_depth: 4
  html_document:
    depth: 4
    fig_width: 14
    highlight: tango
    number_sections: yes
    theme: united
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage

# Including splitters.R in your session

```{r}

source('splitters.R')

```


# General information
splitters is a set of functions for easily splitting dataframes or vectors into multiple windows / subsets.  

There are two groups of split functions: greedy split and n (number of windows) split.  

Each group contains 2 functions:  

*grouping_factor* functions return a factor with window numbers.   
This can be used to subset, aggregate, group_by, etc.  

*split* functions split the given data (dataframe or vector) into the specified windows and return them in a list.

 
## Greedy split
Greedy split uses window **size** for splitting the data.  
Greedy means that each window grabs as many elements as possible (up to size),
meaning that there might be less elements available to the last window.  


&nbsp;  
 
**Example**    

> We have a vector with 57 values. We want to have window sizes of 10.  
>  
> The greedy splitter will return windows with this many values in them:  
> 10, 10, 10, 10, 10, 7  

&nbsp;  

By setting **force_equal** to TRUE, we discard the last window if it contains fewer
values than the other windows.  

&nbsp;  
 
**Example**  

> We have a vector with 57 values. We want to have window sizes of 10.  
>  
> The greedy splitter with force_equal set to TRUE 
> will return windows with this many values in them:  
> 10, 10, 10, 10, 10  
>  
> meaning that 7 values have been discarded.  

&nbsp;  
 

## n split
n split use number of windows (n_windows) for splitting the data.  

With *default settings*, it tries to make the windows as equal as possible, 
but notice that the last window might contain fewer or more elements,
if the length of the data is not divisible with the number of windows.  


&nbsp;  

**Example**    

> We have a vector with 57 values. We want to get back 5 windows.  
>   
> n splitter with default settings would return windows with this many values in them:  
>   
> 11, 11, 11, 11, 13   
 
&nbsp;  

By setting **force_equal** to TRUE, n splitter will create the largest possible, 
equally sized windows by discarding excess data elements.  

&nbsp;  

**Example**    

> n splitter with **force_equal** set to TRUE would return windows with this many values in them:  
>   
> 11, 11, 11, 11, 11  
>  
> meaning that 2 values have been discarded.  

&nbsp;  

Notice that the n splitter will always return the given number of windows. It will never return a 
window with zero elements. For some situations that means that the last window will 
contain a lot of elements. Asked to split a vector with 57 elements into 20 windows, 
the first 19 windows will contain 2 elements, while the last window will itself contain 19 elements. 
Had we instead asked it to split the vector into 19 windows, we would have had 3 elements 
in all windows.

&nbsp;  

## Arguments

### data or v

The data to process.   

**data**: dataframe or vector  
Used in *split* functions  

**v**: vector   
Used in *grouping_factor*  

&nbsp;  

### size or n_windows

**size**: whole number or percentage (Used by greedy splitter)

> Whole number: 1 or above. A size of 10 means that each window will contain 10 elements (possibly not the last window).  
> Percentage: Numeric between 0-1. E.g. 0.1 is 10 percent. If your vector has a length of 100 and size is set to 0.2, each window will contain 20 elements.

**n_windows**: whole number or percentage (Used by n splitter)

> Whole number: 1 or above. A size of 10 means that the splitter will create exactly 10 windows / subsets / data splits.   
> Percentage: Numeric between 0-1. E.g. 0.1 is 10 percent. If your vector has a length of 100 and n_windows is set to 0.2, the splitter will create exactly 20 windows / subsets / data splits.  

&nbsp;  

### force_equal
If you need windows with the exact same size, set force_equal to TRUE.  
Implementation is different in the two kinds of splitters. Read more in their sections above.  
Be aware that this setting discards excess datapoints.  

&nbsp;  


### allow_zero
If you input 0 as size or n_windows (depending on the function), you get an error.  
If you don't want this behavior, you can set allow_zero to TRUE, and (depending on
the function) you will get the following output:  

*grouping_factor* functions return the factor with NAs instead of numbers. It will be
the same length as expected.  

*split* functions will return the given data (dataframe or vector) in the same list format as if it had been split.

&nbsp;  

# Functions

## gsplit_grouping_factor

Greedy split grouping factor  

1. We create a dataframe  

```{r}

df = data.frame("x"=c(1:12), 
                "species" = rep(c('cat','pig', 'human'), 4), 
                "age" = sample(c(1:100), 12))

```

2. Using gsplit_grouping_factor()  
Notice that I only pass it 1 column from the dataframe  

```{r}

df$group = gsplit_grouping_factor(df[,1], 5)

df

```

3. We could get the mean age of each group  

```{r}

aggregate(df[, 3], list(df$group), mean)

```

### force_equal

Getting an equal number of elements per window with gsplit_grouping_factor.  

Notice that we discard the last window that would have contained less elements than the other groups.  
Since the grouping factor is shorter than the dataframe, we can't combine them as they are. A way to do so would be to shorten the dataframe to be the same length as the grouping_factor. 

1. We create a dataframe  

```{r}

df = data.frame("x"=c(1:12), 
                "species" = rep(c('cat','pig', 'human'), 4), 
                "age" = sample(c(1:100), 12))

```

2. Using gsplit_grouping_factor() with force_equal   

```{r}

group = gsplit_grouping_factor(df[,1], 5, force_equal = TRUE)

group

```

3. Combining dataframe and grouping factor  

First we make the dataframe the same size as the grouping factor. Then we add the grouping factor to the dataframe.  

```{r}

df = head(df, length(group))

df$group = group

df

```

&nbsp;  
 
## gsplit

Greedy splitter for both vectors and dataframes  

1. We create a dataframe  

```{r}

df = data.frame("x"=c(1:12), 
                "species" = rep(c('cat','pig', 'human'), 4), 
                "age" = sample(c(1:100), 12))

```

2. Using gsplit() for dataframes   

```{r}

df_list = gsplit(df, 5)

df_list

```

3. We can get a specific dataframe   

```{r}
df_list[[2]]
```

4. We could get the mean of age for that particular dataframe  

```{r}

mean(df_list[[2]]$age)

```

5. Using gsplit() for vectors  

```{r}

# Note that I only pass it one column!
vec_list = gsplit(df[,1], 5)

vec_list

```

3. We can get a specific vector  

```{r}
vec_list[[2]]
```


### force_equal

Getting an equal number of elements per window with gsplit.  

Notice that we discard the last dataframe/vector that would have contained fewer rows/elements than the others.

1. We create a dataframe  

```{r}

df = data.frame("x"=c(1:12), 
                "species" = rep(c('cat','pig', 'human'), 4), 
                "age" = sample(c(1:100), 12))

```

2. Using gsplit() with force_equal on a dataframe  

```{r}

df_list = gsplit(df, 5, force_equal = TRUE)

df_list

```

3. Using gsplit() with force_equal on a vector  

```{r}

# Note that I only pass it one column!
vec_list = gsplit(df[,1], 5, force_equal = TRUE)

vec_list

```



&nbsp;  
 
## nsplit_grouping_factor

Number of windows split grouping factor  

1. We create a dataframe  

```{r}

df = data.frame("x"=c(1:12), 
                "species" = rep(c('cat','pig', 'human'), 4), 
                "age" = sample(c(1:100), 12))

```

2. Using nsplit_grouping_factor()  
Notice that I only pass it 1 column from the dataframe  

```{r}

df$group = nsplit_grouping_factor(df[,1], 5)

df

```

3. We could get the mean age of each group  

```{r}

aggregate(df[, 3], list(df$group), mean)

```


### force_equal

Getting an equal number of elements per window with nsplit_grouping_factor.  

Notice that the last group in the factor now contains the same number of elements as other groups.  
Since the grouping factor is shorter than the dataframe, we can't combine them as they are. We could though shorten the dataframe to be the same length as the grouping_factor. 

1. We create a dataframe  

```{r}

df = data.frame("x"=c(1:12), 
                "species" = rep(c('cat','pig', 'human'), 4), 
                "age" = sample(c(1:100), 12))

```

2. Using nsplit_grouping_factor() with force_equal   

```{r}

group = nsplit_grouping_factor(df[,1], 5, force_equal = TRUE)

group

```

3. Combining dataframe and grouping factor  

First we make the dataframe the same size as the grouping factor. Then we add the grouping factor to the dataframe.  

```{r}

df = head(df, length(group))

df$group = group

df

```

&nbsp;  

## nsplit

Number of windows splitter for both vectors and dataframes.  

1. We create a dataframe  

```{r}

df = data.frame("x"=c(1:12), 
                "species" = rep(c('cat','pig', 'human'), 4), 
                "age" = sample(c(1:100), 12))

```

2. Using nsplit() for dataframes   

```{r}

df_list = nsplit(df, 5)

df_list

```

3. We can get a specific dataframe   

```{r}
df_list[[2]]
```

4. We could get the mean of age for that particular dataframe  

```{r}

mean(df_list[[2]]$age)

```

5. Using nsplit() for vectors  

```{r}

# Note that I only pass it one column!
vec_list = nsplit(df[,1], 5)

vec_list

```

3. We can get a specific vector  

```{r}
vec_list[[2]]
```


### force_equal

Getting an equal number of elements per window with nsplit.  

Notice that the last dataframe/vector now contains the same number of rows/elements as the others.  

1. We create a dataframe  

```{r}

df = data.frame("x"=c(1:12), 
                "species" = rep(c('cat','pig', 'human'), 4), 
                "age" = sample(c(1:100), 12))

```

2. Using nsplit() with force_equal on a dataframe  

```{r}

df_list = nsplit(df, 5, force_equal = TRUE)

df_list

```

3. Using nsplit() with force_equal on a vector  

```{r}

# Note that I only pass it one column!
vec_list = nsplit(df[,1], 5, force_equal = TRUE)

vec_list

```


&nbsp;  
 