% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/partition.R
\name{partition}
\alias{partition}
\title{Create balanced partitions.}
\usage{
partition(data, p = 0.2, cat_col = NULL, num_col = NULL, id_col = NULL,
  id_aggregation_fn = sum, force_equal = FALSE, list_out = TRUE)
}
\arguments{
\item{data}{Dataframe or Vector.}

\item{p}{List / vector of partition sizes.
Given as whole number(s) and/or percentage(s) (\code{0} < \code{n} < \code{1}).
E.g. \eqn{c(0.2, 3, 0.1)}.}

\item{cat_col}{Name of categorical variable to balance between partitions.

 E.g. when training/testing a model for predicting a binary variable (a or b),
 it is necessary to have both represented in both the training set and the test set.

 N.B. If also passing an id_col, cat_col should be constant within each ID.}

\item{num_col}{Name of numerical variable to balance between partitions.

 N.B. When used with \code{id_col}, values in \code{num_col} for each ID are aggregated using \code{id_aggregation_fn} before being balanced.}

\item{id_col}{Name of factor with IDs. Used to keep all rows that share an ID in
 the same partition (if possible).

 E.g. If we have measured a participant multiple times and want to see the
 effect of time, we want to have all observations of this participant in
 the same partition.}

\item{id_aggregation_fn}{Function for aggregating values in \code{num_col} for each ID, before balancing \code{num_col}.

 N.B. Only used when \code{num_col} and \code{id_col} are both specified.}

\item{force_equal}{Discard excess data. (Logical)}

\item{list_out}{Return partitions in a list. (Logical)}
}
\value{
If \code{list_out is TRUE}:

A list of partitions where partitions are dataframes.

If \code{list_out is FALSE}:

A dataframe with grouping factor for subsetting.
}
\description{
Splits data into partitions.
 Balances a given categorical variable and/or numerical variable between partitions and keeps (if possible)
 all data points with a shared ID (e.g. participant_id) in the same partition.
}
\details{
\subsection{cat_col}{
   \enumerate{
     \item Data is subset by \code{cat_col}.
     \item Subsets are partitioned and merged.
   }
 }

 \subsection{id_col}{
   \enumerate{
     \item Partitions are created from unique IDs.
   }
 }

 \subsection{num_col}{
   \enumerate{
     \item Rows are shuffled.

     \strong{Note} that this will only have an effect on rows that have the same value in num_col.
     \item Rows are ordered as smallest, largest, second smallest, second largest, ...
     \item By their pairwise sum, these are once again ordered as smallest, largest, second smallest, second largest, ...
     \item The ordered data is partitioned.
   }

 N.B. In case \code{data} has an unequal number of rows,
 the row with the largest value is placed in a group by itself in (1), and the order is instead:
 smallest, second largest, second smallest, third largest, ... , largest.
 }

 \subsection{cat_col AND id_col}{
   \enumerate{
     \item Data is subset by \code{cat_col}.
     \item Partitions are created from unique IDs in each subset.
     \item Subsets are merged.
   }
 }

 \subsection{cat_col AND num_col}{
   \enumerate{
     \item Data is subset by \code{cat_col}.
     \item Subsets are partitioned by \code{num_col}.
     \item Subsets are merged.
   }
 }

 \subsection{num_col AND id_col}{
   \enumerate{
     \item Values in \code{num_col} are aggregated for each ID, using \code{id_aggregation_fn}.
     \item The IDs are partitioned, using the aggregated values as "\code{num_col}".
     \item The partition numbers for IDs are transferred to their rows.
   }
 }

 \subsection{cat_col AND num_col AND id_col}{
   \enumerate{
     \item Values in \code{num_col} are aggregated for each ID, using \code{id_aggregation_fn}.
     \item IDs are subset by \code{cat_col}.
     \item The IDs for each subset are partitioned,
     by using the aggregated values as "\code{num_col}".
     \item The partition numbers for IDs are transferred to their rows.
   }
 }
}
\examples{
# Attach packages
library(groupdata2)
library(dplyr)

# Create dataframe
df <- data.frame(
 "participant" = factor(rep(c('1','2', '3', '4', '5', '6'), 3)),
 "age" = rep(sample(c(1:100), 6), 3),
 "diagnosis" = rep(c('a', 'b', 'a', 'a', 'b', 'b'), 3),
 "score" = sample(c(1:100), 3*6))
df <- df \%>\% arrange(participant)
df$session <- rep(c('1','2', '3'), 6)

# Using partition()

# Without balancing
partitions <- partition(df, c(0.2,0.3))

# With cat_col
partitions <- partition(df, c(0.5), cat_col = 'diagnosis')

# With id_col
partitions <- partition(df, c(0.5), id_col = 'participant')

# With num_col
partitions <- partition(df, c(0.5), num_col = 'score')

# With cat_col and id_col
partitions <- partition(df, c(0.5), cat_col = 'diagnosis',
                        id_col = 'participant')

# With cat_col, num_col and id_col
partitions <- partition(df, c(0.5), cat_col = 'diagnosis',
                        num_col = "score",
                        id_col = 'participant')

# Return dataframe with grouping factor
# with list_out = FALSE
partitions <- partition(df, c(0.5), list_out = FALSE)

}
\author{
Ludvig Renbo Olsen, \email{r-pkgs@ludvigolsen.dk}
}
