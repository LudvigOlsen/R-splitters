% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collapse_groups.R
\name{collapse_groups}
\alias{collapse_groups}
\title{Collapse groups with categorical, numerical, and size balancing}
\usage{
collapse_groups(
  data,
  n,
  group_cols,
  balance_size = TRUE,
  cat_col = NULL,
  cat_levels = ".majority",
  num_col = NULL,
  group_aggregation_fn = mean,
  extreme_pairing_levels = 1,
  num_new_group_cols = 1,
  unique_new_group_cols_only = TRUE,
  max_iters = 5,
  combine_method = "avg_standardized",
  combine_weights = c(size = 1, cat = 1, num = 1),
  col_name = ".coll_groups",
  parallel = FALSE
)
}
\arguments{
\item{data}{\code{data.frame}. Can be \emph{grouped}, in which case
the function is applied group-wise.}

\item{n}{Number of new groups.

When \code{`num_new_group_cols` > 1}, \code{`n`} can also be a vector
with one \code{`n`} per new group column. This allows trying multiple \code{`n`}
settings at a time. Note that the generated group columns are not guaranteed
to be in the order of \code{`n`}.}

\item{group_cols}{Name(s) of factor(s) in \code{`data`} for identifying the existing groups
that should be collapsed.

Multiple names are treated as in \code{\link[dplyr:group_by]{dplyr::group_by()}}
(i.e., a hierarchy of groups), where each leaf group within each parent group is
considered a unique group to be collapsed.
Parent groups are not considered during collapsing, why leaf groups from different
parent groups can be collapsed together.

N.B. Do not confuse these group columns with potential columns that \code{`data`} is grouped by.
\code{`group_cols`} identifies the groups to be collapsed. When \code{`data`} is
grouped with \code{\link[dplyr:group_by]{dplyr::group_by()}}, the function is
applied separately to each subset.
TODO Improve this part!!!!}

\item{balance_size}{Whether to balance the size of the collapsed groups. (logical)}

\item{cat_col}{Name of categorical column to balance the average frequency
of a chosen level of between groups.

Note: I have not yet identified a way to quickly and robustly balance frequencies of
multiple levels at once. This may change in the future.}

\item{cat_levels}{Names of the levels in the \code{`cat_col`} column to balance the average frequency
of. When \code{NULL}, all levels are balanced. The balancing is likely to work best with a few levels.

Can be a named numeric vector, where the names are the levels and the values are weights
of importance in the balancing.

Can be \code{".minority"} or \code{".majority"}, in which cases the minority/majority level
are found and used.}

\item{num_col}{Name of numerical column to balance between groups.

Aggregated for each group using \code{`group_aggregation_fn`} before balancing.}

\item{group_aggregation_fn}{Function for aggregating values in \code{`num_col`}
for each group in \code{`group_cols`}, before balancing \code{`num_col`}.

N.B. Only used when \code{`num_col`} is specified.}

\item{extreme_pairing_levels}{How many levels of extreme pairing to do
when balancing the groups by the combined balancing column. (TODO improve)

\strong{Extreme pairing}: Rows/pairs are ordered as smallest, largest,
second smallest, second largest, etc. If \code{extreme_pairing_levels > 1},
this is done "recursively" on the extreme pairs. See \code{`Details/TODODODODO`} for more.

N.B. Larger values work best with large datasets. If set too high,
the result might not be stochastic. Always check if an increase
actually makes the groups more balanced. See example.}

\item{num_new_group_cols}{Number of group columns to create.

If \code{num_new_group_cols > 1}, columns will be named
with a combination of \code{`col_name`} and \code{"_1"}, \code{"_2"}, etc.
E.g. \eqn{".coll_groups_1"}, \eqn{".coll_groups_2"}, etc.

N.B. If \code{`unique_new_group_cols_only`} is \code{TRUE},
we can end up with fewer columns than specified, see \code{`max_iters`}.
E.g. when using balancing, the max. possible number of unique
collapsings is often \code{1}.}

\item{unique_new_group_cols_only}{Check if fold columns are identical and
keep only unique columns.

As the number of column comparisons can be time consuming,
we can run this part in parallel. See \code{`parallel`}.

N.B. We can end up with fewer columns than specified in
\code{`num_new_group_cols`}, see \code{`max_iters`}.

N.B. Only used when \code{`num_new_group_cols` > 1} or (TODODODO: \code{`data`} has existing group columns.)}

\item{max_iters}{Maximum number of attempts at reaching
\code{`num_new_group_cols`} \emph{unique} new group columns.

When only keeping unique new group columns, we risk having fewer columns than expected.
Hence, we repeatedly create the missing columns and remove those that are not unique.
This is done until we have \code{`num_new_group_cols`} unique group columns
or we have attempted \code{`max_iters`} times.
In some cases, it is not possible to create \code{`num_new_group_cols`}
unique combinations of the dataset.
\code{`max_iters`} specifies when to stop trying.
Note that we can end up with fewer columns than specified in \code{`num_new_group_cols`}.

N.B. Only used when \code{`num_new_group_cols` > 1}.}

\item{combine_method}{Method to combine the balancing dimensions by. TODO

\code{"avg_standardized"} or \code{"avg_min_max_scaled"}.}

\item{combine_weights}{Named vector with weights for each of
the balancing dimensions. Can be used to favor balancing of
either size, categorical, or numerical balancing.}

\item{parallel}{Whether to parallelize the group column comparisons,
when \code{`unique_new_group_cols_only`} is \code{TRUE}.

Requires a registered parallel backend.
Like \code{doParallel::registerDoParallel}.}
}
\value{
\code{data.frame} with grouping factor for subsetting in cross-validation.
}
\description{
\Sexpr[results=rd, stage=render]{lifecycle::badge("experimental")}

Collapses a set of groups into a smaller set of groups.

Balance the new groups by a numerical column,
one or more levels of a categorical column,
and/or the number of rows (size).
Note: The more of these you balance at a time,
the less balanced each of them may become.

Can create multiple unique collapsed group columns.
}
\details{
\subsection{cat_col}{
\enumerate{
\item ...
}
}

\subsection{num_col}{
\enumerate{
\item ...
}
}

\subsection{size}{
\enumerate{
\item ...
}
}

\subsection{combined}{
\enumerate{
\item ...
}
}

\subsection{numerical balancing of combined column}{
TODO THIS ONE!
\enumerate{
\item Rows are shuffled.
\strong{Note} that this will only affect rows with the same value in \code{`num_col`}.
\item Extreme pairing 1: Rows are ordered as \emph{smallest, largest, second smallest, second largest}, etc.
Each pair get a group identifier.
\item If \code{`extreme_pairing_levels` > 1}: The group identifiers are reordered as \emph{smallest,
largest, second smallest, second largest}, etc., by the sum of \code{`num_col`} in the represented rows.
These pairs (of pairs) get a new set of group identifiers, and the process is repeated
\code{`extreme_pairing_levels`-2} times. Note that the group identifiers at the last level will represent
\code{2^`extreme_pairing_levels`} rows, why you should be careful when choosing that setting.
\item The final group identifiers are folded, and the fold identifiers are transferred to the rows.
}
N.B. When doing extreme pairing of an unequal number of rows,
the row with the smallest value is placed in a group by itself, and the order is instead:
smallest, \emph{second smallest, largest, third smallest, second largest}, etc.
}
}
\examples{
# Attach packages
library(groupdata2)
library(dplyr)

# Create data frame
df <- data.frame(
  "participant" = factor(rep(c("1", "2", "3", "4", "5", "6"), 3)),
  "age" = rep(sample(c(1:100), 6), 3),
  "diagnosis" = factor(rep(c("a", "b", "a", "a", "b", "b"), 3)),
  "score" = sample(c(1:100), 3 * 6)
)
df <- df \%>\% arrange(participant)
df$session <- rep(c("1", "2", "3"), 6)
}
\seealso{
\code{\link[groupdata2:fold]{fold()}} for creating balanced folds/groups.

\code{\link[groupdata2:partition]{partition()}} for creating balanced partitions.

Other grouping functions: 
\code{\link{all_groups_identical}()},
\code{\link{fold}()},
\code{\link{group_factor}()},
\code{\link{group}()},
\code{\link{partition}()},
\code{\link{splt}()}
}
\author{
Ludvig Renbo Olsen, \email{r-pkgs@ludvigolsen.dk}
}
\concept{grouping functions}
