---
title: "Timeseries"
author: 
  - "Ludvig Renbo Olsen"
date: "`r Sys.Date()`"
abstract: |
  splitters is a set of functions for easy grouping / windowing, folding or splitting of data.
  In this vignette, we will show how to use splitters to group timeseries.
  &nbsp;  
  &nbsp;  
  Contact author at mail@ludvigolsen.dk
  &nbsp; 
  &nbsp;  
  
  -----
output: 
  rmarkdown::html_vignette:
    css: 
    - !expr system.file("rmarkdown/templates/html_vignette/resources/vignette.css", package = "rmarkdown")
    - styles.css
    fig_width: 5
    fig_height: 3
    toc: yes
    number_sections: no
  rmarkdown::pdf_document:
    highlight: tango
    number_sections: yes
    toc: yes
    toc_depth: 4
vignette: >
  %\VignetteIndexEntry{Timeseries}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Vignette development notes

Find new timeseries with smaller resolution and shorter length (file size). I should be able to include it in the package.  
If in this timeseries do() doesn't convert .subgroups to a character, consider giving an example with it anyway.  

Create example with very short timeseries, so it's easy to visualize with kable() what is going on. It is hard 
when window size is 100 and step size 10. Better 10 and 1 ;)  


# Attach Packages 

```{r error=FALSE, message=FALSE}

# Attaching splitters
library(splitters)

# Attaching other packages used in this vignette
library(dplyr)
library(knitr)
library(ggplot2)

```

# Load timeseries data

We will use the dataset austres for this vignette. It contains numbers (in thousands) of Australian residents measured quarterly from March 1971 to March 1994.  

Let's load the data and take a look at it.  

```{r}

timeSeriesFrame = data.frame('residents' = austres)

# Show structure of dataframe
str(timeSeriesFrame)

# Show head of data
timeSeriesFrame %>% head(12) %>% kable(col.names = 'residents')

```

&nbsp;  
&nbsp;  
A visulization of the data.  

```{r echo=FALSE, message=FALSE}
# Plot of timeseries

ggplot(timeSeriesFrame, aes(seq_along(residents), residents)) +
  geom_point() +
  labs(x = 'Measurement', y = 'Residents')


```


# Reduce number of datapoints

Let's say, that instead of having four measures per year, we want 1 measure every 3 years.  
We can do this by making groups of 12 elements each with the 'greedy' method and use the the means of each group as our measurements.  


```{r}
ts = timeSeriesFrame %>%
  
  # Group data
  group(12, method='greedy') %>%
  
  # Find means of each group
  dplyr::summarise(mean = mean(residents))

# Show new data
ts %>% kable() 
```

&nbsp;  
&nbsp;  
A visulization of the data.  

```{r echo=FALSE, message=FALSE}
# Plot of timeseries

ggplot(ts, aes(.groups, mean)) +
  geom_point() +
  labs(x = 'Groups', y = 'Mean n of residents')


```

This leaves us with less datapoints, which could be useful if we had a very large dataframe to start with.  

# Staircase groups 

For the fun of it, let's say we want to make staircased groups inside the greedy groups, we just created. This means that it will start over with step size for every main group.  

When using the staircase method, the last group might not have the size of the second last group + step size. We want to make sure that it does have such size, so we use %staircase% to find a step size with a remainder of 0.


```{r}
main_group_size = 12

# Loop through a list ranging from 1-30
for (step_size in c(1:30)){
  
  # If the remainder is 0
  if(main_group_size %staircase% step_size == 0){
    
    # Print the step size
    print(step_size)
    
  }
  
}

```

So our step size could be 2, 4 or 12. We pick a step size of 2, because it will yield the most subgroups for the example.  

Now we will first make the greedy groups like before, then we will create subgroups with the staircase method.  
In order not to overwrite the '.groups' column from the first use of group(), we will use the col_name argument in group.  
We will also need to use dplyr's do() when using group() on every main group inside the pipeline.  


```{r}
ts <- timeSeriesFrame %>%
  
  # Group data
  group(12, method='greedy') %>%
  
  # Create subgroups
  do(group(., 2, method='staircase', col_name = '.subgroups'))

# Show head of new data
ts %>% head(24) %>% kable() 

```

Notice the warning in the previous code. On some timeseries the do() step converts the column '.subgroups' from a factor into a character because of unequal factor levels. This is likely because the last main group contains less elements than the other groups, and so, we are able to make fewer subgroups. Let's check the tail of the new dataframe.

```{r}
# Show tail of new data
ts %>% tail(17) %>% kable()

```

Sure enough, the last main group is smaller. This means that there are only 2 subgroups instead of 3. To solve this, so the timeseries is a factor sorted by its integers, we first convert it to an integer and then to a factor.  

We could also get the means of each subgroup. To do this we first group by .groups and then .subgroups. Then we take the mean of all subgroups. If we had just grouped by .subgroups, we would have taken the mean of all the datapoints in each subgroup level. This would have left us with (in this case) 3 means, instead of 1 per subgroup level per main group level.  

```{r}

ts_means <- ts %>%
  
  # Convert .subgroups to an integer and then to a factor
  mutate(.subgroups = as.integer(.subgroups),
         .subgroups = as.factor(.subgroups)) %>%
  
  # Group by first .groups, then .subgroups
  group_by(.groups, .subgroups) %>%
  
  # Find the mean of each subgroup
  dplyr::summarise(mean = mean(residents))

# Show head of new data
ts_means %>% head(9) %>% kable() 
```

&nbsp;  
&nbsp;  
A visulization of the data.  

```{r echo=FALSE, message=FALSE}
# Plot of timeseries

ggplot(ts_means, aes(seq_along(mean), mean)) +
  geom_point() +
  labs(x = 'Subgroups', y = 'Mean n of residents')


```




```{r}



```




